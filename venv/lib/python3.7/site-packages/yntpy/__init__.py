import inspect
from enum import Enum
from cryptography.fernet import Fernet
from flask import request, g
from flask_jwt_extended import decode_token
from uuid import uuid4
import base64
import asyncio
import datetime
import re

loop = asyncio.new_event_loop()


def fire_and_forget(f):
    def wrapped(*args, **kwargs):
        # print(inspect.getargvalues(inspect.currentframe()))
        # if f.__name__ == "notify_user":
            # for arg in args:
            #     print(arg)
            # print("args:" ,args)
            # print("kwargs:", kwargs)
        asyncio.set_event_loop(loop)
        return asyncio.get_event_loop().run_in_executor(None, f, *args, *kwargs)

    return wrapped


class LogTypeEnum(str, Enum):
    REQUEST = 'request'
    RESPONSE = 'response'


class LoggerTypeEnum(str, Enum):
    INFO = 'info'
    DEBUG = 'debug'
    ERROR = 'error'
    WARNING = 'warning'


class Logger:
    """
    This class provides encapsulation for logger.
    Initialize it on application __init__.py
    logger = Logger()
    Than on create_app method initialize application:
    logger.init_app(app)
    """

    def __init__(self):
        self.logger = None

    def init_app(self, app):
        """
        :param app: Flask app instance
        :return: void
        """
        self.logger = app.logger

    def log(self, message, logger_type):
        """

        :param message: Log message
        :param logger_type: LoggerTypeEnum
        :return: float: log_id(unique identifier)
        """
        if not self.logger:
            raise Exception('No application supplied in init_app')
        # Create GUID
        if not logger_type:
            logger_type = LoggerTypeEnum.INFO
        log_id = uuid4()
        prepared_message = 'LOG_ID: {} - MESSAGE: {}'.format(log_id, message)
        logger_dictionary = {LoggerTypeEnum.DEBUG: self.logger.debug,
                             LoggerTypeEnum.INFO: self.logger.info,
                             LoggerTypeEnum.ERROR: self.logger.error,
                             LoggerTypeEnum.WARNING: self.logger.warning}

        logger_dictionary.get(logger_type, LoggerTypeEnum.DEBUG)(prepared_message)
        return log_id


class Cipher:
    """
    Cipher based on Fernet cryptography
    """

    def __init__(self):
        self.cipher = None

    def init_app(self, key):
        self.cipher = Fernet(key)

    def encrypt(self, plain_text):
        """
        plain_text to encrpyted base64 encoded string
        :param plain_text: string: plain_text
        :return: encrypted base64 encoded string
        """
        encrypted_text = self.cipher.encrypt(plain_text.encode())
        b64_encoded_string = base64.b64encode(encrypted_text).decode('utf-8')
        return b64_encoded_string

    def decrypt(self, b64_encoded_string):
        """
        encrpyted base64 encoded string to plain_text
        :param b64_encoded_string:
        :return: decrypted plain text
        """
        b64_decoded_string = base64.b64decode(b64_encoded_string)
        decrypted_text = self.cipher.decrypt(b64_decoded_string)
        result = decrypted_text.decode('utf-8')
        return result


class MongoLogger:
    def __init__(self):
        self.log_collection = None
        self.file_logger = None
        self.app = None
        self.api = None
        self.registered_endpoints = []
        self.registered_urls = []
        self.loop = asyncio.new_event_loop()
        self.compiled_regex = re.compile('<.*?>.*')

    def init_mongo_logger(self, log_collection):
        self.log_collection = log_collection

    def init_api(self, api):
        self.api = api
        self.app = api.app

    def register(self):
        def wrapper(cls):
            if cls not in self.registered_endpoints:
                self.registered_endpoints.append(cls)

        return wrapper

    def create_log(self, log_type, log_body=dict()):
        try:
            log = dict()
            log['type'] = log_type
            log['path'] = request.path
            if request.environ.get('HTTP_X_FORWARDED_FOR') is None:
                log['ip_address'] = request.environ['REMOTE_ADDR']
            else:
                log['ip_address'] = request.environ['HTTP_X_FORWARDED_FOR']
            log['request_method'] = request.method
            log['log_id'] = g.job_id
            log['payload'] = log_body
            log['identity'] = g.identity
            log['create_date'] = datetime.datetime.utcnow()
            return log
        except Exception as ex:
            return {'exception': ex, 'log_id': g.job_id, 'payload': log_body}

    @fire_and_forget
    def log_to_db(self, log):
        try:
            _ = self.log_collection.insert_one(log, {'writeConcern': 0})
        except:
            pass

    @fire_and_forget
    def log(self, log):
        if self.log_collection:
            self.log_to_db(log)

    def initialize_app_handlers(self):
        @self.app.before_first_request
        def before_first_request():
            for registered in self.registered_endpoints:
                for resource in self.api.resources:
                    if resource[0] == registered:
                        url = '{}{}'.format(self.api.base_path, resource[2][0])
                        if url not in self.registered_urls:
                            self.registered_urls.append(url)

        @self.app.after_request
        def after(response):
            for registered_url in self.registered_urls:
                if self.compiled_regex.sub('', registered_url) in request.path:
                    g.job_id = str(uuid4())
                    try:
                        g.identity = decode_token(request.headers.get('Authorization').replace('Bearer ', ''))[
                            'identity']
                    except:
                        g.identity = None

                    log_body = self.create_log(log_type=LogTypeEnum.REQUEST, log_body=self.api.payload)
                    self.log(log_body)

                    if response.json:
                        log_body = self.create_log(log_type=LogTypeEnum.RESPONSE, log_body=response.json)
                        self.log(log_body)
                    break

            return response
